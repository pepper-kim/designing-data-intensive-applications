## 요약
- 4p, 현대 소프트웨어들은 많은 데이터를 다루며, 따라서 데이터 중심의 설계가 필요하다.
- 5p, 현대 애플리케이션은 작업을 단일 도구에서 효율적으로 수행할 수 있는 task 들로 나누고, 애플리케이션의 코드를 이용해서 다양한 도구들을 연결해 사용한다.
- 6p, 소프트웨어 시스템에서 중요하게 여기는 3가지의 관심사 - 신뢰성, 확장성, 유지보수성
- 6p, ***신뢰성***
    - 신뢰성의 의미 - `결함(fault)`이 발생하더라도 지속적으로 올바르게 동작함
        - 결함(fault)  - 잘못될 수 있는 일
    - 결함을 예측하고 대처할 수 있는 시스템을 `내결함성(fault-tolerant)` 또는 `탄력성(resilent)`을 지녔다고 말한다.
        - 이 때 내결함성은 특정 유형의 결함 내성에 한정한다. (모든 결함x)
    - **결함은 `장애(failure)`와 동일하지 않다.** 결함은 사양에서 벗어난 시스템의 한 구성 요소로 정의 되지만, 장애는 사용자에게 필요한 서비스를 제공하지 못하고 시스템 전체가 멈춘 경우다.
        - *결함이 장애로 이어지지 않도록 내결함성 구조를 설계하는 것이 가장 좋다.*
            - ex. 넷플릭스의 카오스 몽키
    - 하드웨어 결함은 현대에는 **소프트웨어 내결함성 기술 + 하드웨어 중복성**을 통해 전체 장비의 손실을 견딜 수 있는 구조로 옮겨가고 있다.
        - 아마존의 경우, 장비 신뢰성보다 유연성(flexibility)과 탄력성(elasticity)을 우선처리하도록 설계되었다. (가상 os, 컨테이너 기술이 뒷밤침되었기에..)
    - 소프트웨어 오류는 하드웨어 결함에 비해 더 많은 시스템 오류를 유발한다. 하드웨어 간에는 오류 상관성이 적은 반면, 소프트웨어는 크기 때문이다.
    - 인적 오류 또한 하드웨어 결함 보다 훨씬 큰 서비스 중단 요소이다.
    - 신뢰성은 사용자에 대한 책임(responsibility)과 관련된다.
- 11p, ***확장성***
    - 확장성의 의미 - 증가한 부하에 대처하는 시스템 능력
        - 그러나 오히려 “X는 확장 가능하다”, “Y는 확장성이 없다” 라는 질문과는 관련이 없으며
        - “시스템이 특정 방식으로 커지면 이에 대처하기 위한 선택은 무엇인가?”, “추가 부하를 다루기 위해 계산 자원은 어떻게 투입할까?” 같은 질문을 고려한다는 의미이다.
    - 부하 매개변수(load parameter)를 통해 시스템의 현재 부하를 간결히 기술할 수 있으며, 부하 성장 질문을 논의 할 수 있다.(if 부하가 2배가 된다면?)
        - 적합한 부하 매개변수 선택은 시스템 설계에 따라 달라진다.
        - twitter의 경우, 확장성 문제는 주로  트윗 쓰기 이후의`fan-out`(트랜잭션 처리 시스템에서 하나의 수신 요청을 처리하는 데 필요한 다른 서비스의 요청 수)과 관련된다.
            - 트위터는 쓰기 시점에 더 많은 일을 하고, 읽기 시점에 더 적은 일을 하도록 하여 확장성 문제를 해결했다. (일부 많은 팔로워를 가진 유저를 고려하여 hybrid 방식을 사용하기도 함)
    - 시스템 부하를 기술하면 부하 증가 시 어떤 일이 일어나는지 조사할 수 있다. 다음 2가지 방법으로 살펴볼 수 있다.
        - “부하 매개변수를 증가시키고 시스템 자원은 변경하지 않고 유지하면 시스템 성능은 어떻게 영향을 받을까?”
        - “부하 매개변수를 증가시켰을 때 성능이 변하지 않고 유지되길 원한다면 자원을 얼마나 많이 늘려야 할까?”
    - 이를 설명할 수 있는 성능 수치로 “`처리량(throughput)`”, 응답 시간`(response time)`이 있다. 보통 온라인 시스템에서는 응답 시간이 더 중요한 수치가 된다.
        - 처리량 - 초당 처리할 수 있는 레코드 수 or 일정 크기의 데이터 집합으로 작업을 수행할 때 걸리는 전체 시간
        - 지연 시간(latency)과 응답 시간(response time)은 다르다. 응답 시간은 클라이언트 관점에서 본 시간으로, 요청을 처리하는 실제 시간(서비스 시간) 외에도 네트워크 지연과 큐 지연도 포함한다. 지연 시간은 요청이 처리되길 기다리는 시간으로, 서비스를 기다리며 휴지(latent) 상태인 시간을 말한다. =⇒ 클라: 응답 시간, 서버: 지연 시간
    - 응답 시간을 평가할 때, 산술 평균(arithmetic mean)보다는 백분위(percentile)을 사용하는 것이 좋다.
        - 산술 평균은 얼마나 많은 사용자가 실제로 지연을 경험했는지 알려주지 않기 때문.
        - 백분위를 통해서 중앙값(median, 50분위, p50)을 얻어낼 수 있고, 상위 백분위를 살펴볼 수 있다.
        - `상위 백분위(== 꼬리 지연 시간)`는 보통 `p95, p99, p999` 이다.
            - 서비스의 사용자 경험에 직접 영향을 주기 때문에 중요하다.
                - *ex. 아마존의 경우, 내부 서비스의 응답 시간 요구사항을  p999로 기술한다. 이는 “보통 응답 시간이 가장 느린 요청을 경험한 고객들은 많은 구매를 해서 고객 중에서 계정에 가장 많은 데이터를 갖고 있다”는 전제에 의거한다. 한편, 99.99분위는 고려하지 않는다(roi x).*
        - 백분위는 서비스 수준 목표(SLO), 서비스 수준 협약서(SLA)에 사용되기도 한다.
        - 응답 시간 데이터를 집계하는 올바른 방법은 히스토그램을 추가하는 것이다.
    - **부하 대응 접근 방식**
        - 보통 scaling up, scaling out 고려. → 이처럼 다수의 장비에 부하를 분산하는 아키텍처를 `비공유(shared-nothing)` 아키텍처라고 부른다. 다수의 장비에 상태 비저장(stateless) 서비스를 배포하는 일은 상당히 간단하다. but 상태 유지(stateful) 데이터 시스템을 분산 설치하는 일은 아주 많은 복잡도가 추가적으로 발생한다.
            - 최근까지의 통념은 확장비용, db 분산 요구되는 고가용성 요구 전까지는 단일 노드에 db를 유지(용량 확장)하는 것을 택하는 것이다.
        - one-size-fits-all 아키텍처는 없다.
        - 특정 애플리케이션에 적합한 확장성을 갖춘 아키텍처는 주요 동작이 무엇이고 잘하지 않는 동작이 무엇인지에 대한 가정을 바탕으로 구축한다. 그리고 이 가정은 부하 매개변수가 된다..
- **19p,** *유지보수성*
    - 유지보수 중 고통을 최소화하고 레거시 소프트웨어를 직접 만들지 않게끔 설계하는 원칙 3가지
        - 운용성(operability), 단순성(simplicity), 발전성(evlovablility)
    - 운용성
        - **운영팀이** 시스템을 원활하게 **운영할 수 있게 쉽게** 만들어라.
        - 좋은 운영성이란 “동일하게 반복되는 태스크를 쉽게 수행하게끔 만들어 운영팀이 고부가가치 활동에 노력을 집중한다는 의미”
            - 동일 반복 태스트를 자동화하라.
    - 단순성: 복잡도 관리
        - 시스템에서 복잡도를 최대한 제거해 **새로운 엔지니어가 시스템을** **이해하기 쉽게** 만들어라 (사용자 인터페이스의 단순성과는 다르다)
        - 상태 공간의 급증, 모듈 간 강한 커플링, 복잡한 의존성 등..
        - 복잡도를 줄이면 소프트웨어 유지보수성이 크게 향상되며, 따라서 단순성이 구축하려는 시스템의 핵심 목표여야 한다.
        - 우발적 복잡도(accidental complexity)
            - 제거하기 위한 가장 좋은 도구는 추상화다. 깔끔한 외관 아래 세부 구현 숨기기.
    - 발전성: 변화를 쉽게 만들기
        - 엔지니어가 이후에 시스템을 쉽게 변경할 수 있도록 하기
    
    
---
## 정리
    
    - 유용한 애플리케이션을 위한 비기능적 요구사항인 신뢰성, 확장성, 유지보수성을 살펴봄.
    - **신뢰성**은 결함이 발생해도 시스템이 올바르게 동작하게 만든다는 의미
    - **확장성**은 부하가 증가해도 좋은 성능을 유지하기 위한 전략
    - 유지보수성의 본질은 시스템에서 작업하는 엔지니어와 운영팀의 삶을 개선하는 것.
    
---
## 키워드
    
    - `신뢰성의 의미` - 결함(fault)이 발생하더라도 지속적으로 올바르게 동작함
    - `결함(fault)`  - 잘못될 수 있는 일
    - `내결함성(fault-tolerant, 탄력성(resilent))` - 결함을 예측하고 대처할 수 있는 시스템
    - `확장성의 의미` - 증가한 부하에 대처하는 시스템 능력
    - `fan-out` - 트랜잭션 처리 시스템에서 하나의 수신 요청을 처리하는 데 필요한 다른 서비스의 요청 수
    - `응답 시간(response time)` -  클라이언트 관점에서 본 시간으로, 요청을 처리하는 실제 시간(서비스 시간) 외에도 네트워크 지연과 큐 지연도 포함한다.
    - `지연 시간(latency)` - 요청이 처리되길 기다리는 시간으로, 서비스를 기다리며 휴지(latent) 상태인 시간을 말한다.
    - `산술 평균(arithmetic mean)` - 모두 합쳐서 n으로 나눈 값
    - `백분위(percentile)` - 크기에 따라 나열한 값
    - `상위 백분위(= 꼬리 지연 시간, tail latency)` - 보통 p95, p99, p999
    - `비공유(shared-nothing) 아키텍처` - 다수의 장비에 부하를 분산하는 아키텍처
    - `우발적 복잡도(accidental complexity)` - 소프트웨어나 시스템의 복잡도 중 불필요하거나 피할 수 있는 부분을 의미한다. 즉, 문제 자체의 복잡함이 아니라 개발자나 설계자의 선택, 도구, 기술 등으로 인해 발생하는 복잡함.
    
---
## 기억하고 싶은 키워드, 문장

- *확장성은 오히려 “X는 확장 가능하다”, “Y는 확장성이 없다” 라는 질문과는 관련이 없으며 “시스템이 특정 방식으로 커지면 이에 대처하기 위한 선택은 무엇인가?”, “추가 부하를 다루기 위해 계산 자원은 어떻게 투입할까?” 같은 질문을 고려한다는 의미이다.*
- *아마존의 경우, 내부 서비스의 응답 시간 요구사항을  p999로 기술한다. 이는 “보통 응답 시간이 가장 느린 요청을 경험한 고객들은 많은 구매를 해서 고객 중에서 계정에 가장 많은 데이터를 갖고 있다”는 전제에 의거한다. 한편, 99.99분위는 고려하지 않는다(roi x).*
- “부하 매개변수를 증가시키고 시스템 자원은 변경하지 않고 유지하면 시스템 성능은 어떻게 영향을 받을까?” (얼마나 부하를 견딜 수 있을까?)
- “부하 매개변수를 증가시켰을 때 성능이 변하지 않고 유지되길 원한다면 자원을 얼마나 많이 늘려야 할까?” (언제 스케일 아웃을 해야 할까?)
- *결함을 예측하고 대처할 수 있는 시스템을 `내결함성(fault-tolerant)` 또는 `탄력성(resilent)`을 지녔다고 말한다.*
- ***결함은 `장애(failure)`와 동일하지 않다.** 결함은 사양에서 벗어난 시스템의 한 구성 요소로 정의 되지만, 장애는 사용자에게 필요한 서비스를 제공하지 못하고 시스템 전체가 멈춘 경우다.*
- *결함이 장애로 이어지지 않도록 내결함성 구조를 설계하는 것이 가장 좋다.*